# -*- coding: utf-8 -*-
"""03-taskA-SummarisationEnsemble.ipynb

Automatically generated by Colaboratory.
"""

import pandas as pd
import sys
from sentence_transformers import SentenceTransformer, util

model_sentence_transformers = SentenceTransformer('all-MiniLM-L6-v2')

"""## Load Test Data to read dialogues"""

test = pd.read_csv(sys.argv[1])
dia = test['dialogue'].str.lower().tolist()

"""# Reading Task-A Summaries generated from different models"""

import pickle
pred1 = pickle.load(open(f'intermediate_outputs/{sys.argv[2]}/taska_summary_bart_large_ontest.pkl', 'rb')) #bart large summary
pred2 = pickle.load(open(f'intermediate_outputs/{sys.argv[2]}/taska_summary_biobart_large_ontest.pkl', 'rb')) #biobart-large summary
pred3 = pickle.load(open(f'intermediate_outputs/{sys.argv[2]}/taska_summary_gpt3_ontest.pkl', 'rb')) #gpt-3 summary

"""# Ensemble Task-A summaries"""

import numpy as np

def similarity(s1, s2):
  embeddings1 = model_sentence_transformers.encode(s1, convert_to_tensor=True)
  embeddings2 = model_sentence_transformers.encode(s2, convert_to_tensor=True)
  cosine_scores = util.cos_sim(embeddings1, embeddings2)
  return float(cosine_scores[0][0])

def select_one(all_preds):
  C={}
  for i in range(len(all_preds)):
    sim=[]
    for j in range(len(all_preds)):
      if i!=j:
        sim.append(similarity(all_preds[i], all_preds[j]))
    C[all_preds[i]] = np.mean(sim)
  return C

def jaccard_sim(list1, list2):
    intersection = len(list(set(list1).intersection(list2)))
    union = (len(set(list1)) + len(set(list2))) - intersection
    return float(intersection) / union

def select_two(all_preds, m):
  score2 = {}
  for i in all_preds:
    score = jaccard_sim(i.lower().split(),m.split())
    score2[i] = score
  return score2

def blend_scores(score1, score2):
  final_scores = {}
  for k,v in score1.items():
    final_scores[k] = 0.5*v + 0.5*score2[k]
  resp = sorted(final_scores.items(), key=lambda item: item[1], reverse=True)
  return resp

def ensemble(pred1, pred2, pred3, dia):
  prediction = []
  for i,j,k,m in zip(pred1, pred2, pred3, dia):
    all_preds = [i,j,k]
    score1 = select_one(all_preds)
    score2 = select_two(all_preds, m.lower())
    final_scores = blend_scores(score1, score2)
    prediction.append(final_scores[0][0])
  return prediction

final_summary = ensemble(pred1, pred2, pred3, dia)

test_predictions_with_ids = []
for i,j in zip(test['ID'].tolist(), final_summary):
  test_predictions_with_ids.append([i,j])

test_df = pd.DataFrame(test_predictions_with_ids, columns = ['ID', 'SystemOutput2'])
test_df.to_csv(f'intermediate_outputs/{sys.argv[2]}/final_taska_summarization_output_ontest.csv', index=False)

